/*
** i_system.cpp
** Timers, pre-console output, IWAD selection, and misc system routines.
**
**---------------------------------------------------------------------------
** Copyright 1998-2009 Randy Heit
** Copyright (C) 2007-2012 Skulltag Development Team
** Copyright (C) 2007-2016 Zandronum Development Team
** All rights reserved.
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions
** are met:
**
** 1. Redistributions of source code must retain the above copyright
**    notice, this list of conditions and the following disclaimer.
** 2. Redistributions in binary form must reproduce the above copyright
**    notice, this list of conditions and the following disclaimer in the
**    documentation and/or other materials provided with the distribution.
** 3. The name of the author may not be used to endorse or promote products
**    derived from this software without specific prior written permission.
** 4. Redistributions in any form must be accompanied by information on how to
**    obtain complete source code for the software and any accompanying software
**    that uses the software. The source code must either be included in the
**    distribution or be available for no more than the cost of distribution plus
**    a nominal fee, and must be freely redistributable under reasonable
**    conditions. For an executable file, complete source code means the source
**    code for all modules it contains. It does not include source code for
**    modules or files that typically accompany the major components of the
**    operating system on which the executable file runs.
**
** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**---------------------------------------------------------------------------
**
*/

// HEADER FILES ------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <process.h>
#include <time.h>
#include <map>

#include <stdarg.h>

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windows.storage.streams.h>
#include <windows.security.cryptography.h>

//#include "hardware.h"
#include "printf.h"

#include "version.h"
#include "i_sound.h"
//#include "resource.h"
#include "stats.h"
#include "v_text.h"
#include "utf8.h"

//#include "i_input.h"
#include "c_cvars.h"
#include "c_dispatch.h"
#include "templates.h"
#include "gameconfigfile.h"
#include "v_font.h"
#include "i_system.h"
#include "bitmap.h"
#include "cmdlib.h"
#include "i_interface.h"
#include "engineerrors.h"
#include "m_argv.h"
#include <ppltasks.h>

// MACROS ------------------------------------------------------------------

#ifdef _MSC_VER
// Turn off "conversion from 'LONG_PTR' to 'LONG', possible loss of data"
// generated by SetClassLongPtr().
#pragma warning(disable:4244)
#endif

// TYPES -------------------------------------------------------------------

// EXTERNAL FUNCTION PROTOTYPES --------------------------------------------

extern void LayoutMainWindow(HWND hWnd, HWND pane);

// PUBLIC FUNCTION PROTOTYPES ----------------------------------------------

void DestroyCustomCursor();

// PRIVATE FUNCTION PROTOTYPES ---------------------------------------------

static HCURSOR CreateCompatibleCursor(FBitmap &cursorpic, int leftofs, int topofs);
static HCURSOR CreateAlphaCursor(FBitmap &cursorpic, int leftofs, int topofs);
static HCURSOR CreateBitmapCursor(int xhot, int yhot, HBITMAP and_mask, HBITMAP color_mask);

// EXTERNAL DATA DECLARATIONS ----------------------------------------------

EXTERN_CVAR (Bool, queryiwad);
// Used on welcome/IWAD screen.
EXTERN_CVAR (Bool, disableautoload)
EXTERN_CVAR (Bool, autoloadlights)
EXTERN_CVAR (Bool, autoloadbrightmaps)
EXTERN_CVAR (Bool, autoloadwidescreen)
EXTERN_CVAR (Int, vid_preferbackend)

extern HWND Window, ConWindow, GameTitleWindow;
extern HANDLE StdOut;
extern bool FancyStdOut;
extern HINSTANCE g_hInst;
extern FILE *Logfile;
extern bool NativeMouse;
extern bool ConWindowHidden;

// PUBLIC DATA DEFINITIONS -------------------------------------------------

CVAR (String, queryiwad_key, "shift", CVAR_GLOBALCONFIG|CVAR_ARCHIVE);
CVAR (Bool, con_debugoutput, false, 0);

double PerfToSec, PerfToMillisec;

UINT TimerPeriod;

int sys_ostype = 0;

// PRIVATE DATA DEFINITIONS ------------------------------------------------

static WadStuff *WadList;
static int NumWads;
static int DefaultWad;

static HCURSOR CustomCursor;

TArray<FString> I_GetExtraArgs()
{
	TArray<FString> fileArgs;
	if (FileExists(".\\args.txt"))
	{
		FileReader reader;
		if (reader.OpenFile(".\\args.txt"))
		{
			auto filetext = reader.Read();
			filetext.Push(0);
			auto filetextstr = FString(filetext);
			filetextstr.Split(fileArgs, "\r\n", FString::TOK_SKIPEMPTY);
			reader.Close();
		}
	}
	return fileArgs;
}

void I_AppendExtraArg(FString arg)
{
	auto currentExtraArgs = I_GetExtraArgs();
	currentExtraArgs.Push(arg);
	FILE* argFile = fopen(".\\args.txt", "wb");
	if (argFile)
	{
		for (int i = 0; i < currentExtraArgs.Size(); i++)
			fprintf(argFile, "%s\r\n", currentExtraArgs[i].GetChars());
		fclose(argFile);
	}
}

void I_SetExtraArg(FString arg, int index)
{
	auto currentExtraArgs = I_GetExtraArgs();
	if (index >= currentExtraArgs.Size())
	{
		Printf(TEXTCOLOR_RED "Index must be between 0 and %d\n", currentExtraArgs.Size() - 1);
		return;
	}
	currentExtraArgs[index] = arg;
	FILE* argFile = fopen(".\\args.txt", "wb");
	if (argFile)
	{
		for (int i = 0; i < currentExtraArgs.Size(); i++)
		fprintf(argFile, "%s\r\n", currentExtraArgs[i].GetChars());
		fclose(argFile);
	}
}

CCMD(uwpappdatadir)
{
	Printf("%s\n", (const char*)FString(Windows::Storage::ApplicationData::Current->LocalFolder->Path->Data()));
}

CCMD(uwpprintargs)
{
	for (auto &curarg : *Args)
	{
		Printf("%s\n", curarg.GetChars());
	}
}

CCMD(uwpprintqueuedargs)
{
	auto textargs = I_GetExtraArgs();
	for (int i = 0; i < textargs.Size(); i++)
	{
		Printf(TEXTCOLOR_GREEN "[%d] = %s\n", i, textargs[i].GetChars());
	}
}

CCMD(uwpappendargs)
{
	if (argv.argc() >= 2)
	{
		for (int i = 0; i < argv.argc(); i++)
		{
			if (FString(argv[i]) == FString("uwpappendargs")) continue;
			I_AppendExtraArg(argv[i]);
		}
	}
}
CCMD(uwpsetarg)
{
	if (argv.argc() >= 3)
	{
		FString number = argv[2];
		if (number.IsInt() || number[0] == '0')
		{
			auto index = number.ToLong();
			I_SetExtraArg(argv[1], (int)index);
		}
		else Printf(TEXTCOLOR_RED "Second argument must be a number.\n");
	}
	else Printf(TEXTCOLOR_RED "At least 2 arguments required.\n");
}
//==========================================================================
//
// I_DetectOS
//
// Determine which version of Windows the game is running on.
//
//==========================================================================

void I_DetectOS(void)
{
	OSVERSIONINFOEX info;
	const char *osname;

	info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	if (!GetVersionEx((OSVERSIONINFO *)&info))
	{
		// Retry with the older OSVERSIONINFO structure.
		info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		GetVersionEx((OSVERSIONINFO *)&info);
	}

	switch (info.dwPlatformId)
	{
	case VER_PLATFORM_WIN32_NT:
		osname = "NT";
		if (info.dwMajorVersion == 6)
		{
			if (info.dwMinorVersion == 0)
			{
				osname = (info.wProductType == VER_NT_WORKSTATION) ? "Vista" : "Server 2008";
				sys_ostype = 2; // legacy OS
			}
			else if (info.dwMinorVersion == 1)
			{
				osname = (info.wProductType == VER_NT_WORKSTATION) ? "7" : "Server 2008 R2";
				sys_ostype = 2; // supported OS
			}
			else if (info.dwMinorVersion == 2)	
			{
				// Starting with Windows 8.1, you need to specify in your manifest
				// the highest version of Windows you support, which will also be the
				// highest version of Windows this function returns.
				osname = (info.wProductType == VER_NT_WORKSTATION) ? "8" : "Server 2012";
				sys_ostype = 2; // supported OS
			}
			else if (info.dwMinorVersion == 3)
			{
				osname = (info.wProductType == VER_NT_WORKSTATION) ? "8.1" : "Server 2012 R2";
				sys_ostype = 2; // supported OS
			}
			else if (info.dwMinorVersion == 4)
			{
				osname = (info.wProductType == VER_NT_WORKSTATION) ? "10 (beta)" : "Server 2016 (beta)";
			}
		}
		else if (info.dwMajorVersion == 10)
		{
			osname = (info.wProductType == VER_NT_WORKSTATION) ? "10 (or higher)" : "Server 2016 (or higher)";
			sys_ostype = 3; // modern OS
		}
		break;

	default:
		osname = "Unknown OS";
		break;
	}

	if (!batchrun) Printf ("OS: Windows %s (NT %lu.%lu) Build %lu\n    %s\n",
			osname,
			info.dwMajorVersion, info.dwMinorVersion,
			info.dwBuildNumber, info.szCSDVersion);
}

//==========================================================================
//
// CalculateCPUSpeed
//
// Make a decent guess at how much time elapses between TSC steps. This can
// vary over runtime depending on power management settings, so should not
// be used anywhere that truely accurate timing actually matters.
//
//==========================================================================

void CalculateCPUSpeed()
{
	LARGE_INTEGER freq;

	QueryPerformanceFrequency (&freq);

	if (freq.QuadPart != 0)
	{
		LARGE_INTEGER count1, count2;
		cycle_t ClockCalibration;
		DWORD min_diff;

		ClockCalibration.Reset();

		// Count cycles for at least 55 milliseconds.
        // The performance counter may be very low resolution compared to CPU
        // speeds today, so the longer we count, the more accurate our estimate.
        // On the other hand, we don't want to count too long, because we don't
        // want the user to notice us spend time here, since most users will
        // probably never use the performance statistics.
        min_diff = freq.LowPart * 11 / 200;

		// Minimize the chance of task switching during the testing by going very
		// high priority. This is another reason to avoid timing for too long.
		SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
		SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

		// Make sure we start timing on a counter boundary.
		QueryPerformanceCounter(&count1);
		do { QueryPerformanceCounter(&count2); } while (count1.QuadPart == count2.QuadPart);

		// Do the timing loop.
		ClockCalibration.Clock();
		do { QueryPerformanceCounter(&count1); } while ((count1.QuadPart - count2.QuadPart) < min_diff);
		ClockCalibration.Unclock();

		SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
		SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);

		PerfToSec = double(count1.QuadPart - count2.QuadPart) / (double(ClockCalibration.GetRawCounter()) * freq.QuadPart);
		PerfToMillisec = PerfToSec * 1000.0;
	}

	if (!batchrun) Printf ("CPU speed: %.0f MHz\n", 0.001 / PerfToMillisec);
}

//==========================================================================
//
// I_MakeRNGSeed
//
// Returns a 32-bit random seed, preferably one with lots of entropy.
//
//==========================================================================

unsigned int I_MakeRNGSeed()
{
	return Windows::Security::Cryptography::CryptographicBuffer::GenerateRandomNumber();
}

//==========================================================================
//
// I_GetLongPathName
//
// Returns the long version of the path, or the original if there isn't
// anything worth changing.
//
//==========================================================================

FString I_GetLongPathName(const FString &shortpath)
{
	std::wstring wshortpath = shortpath.WideString();
	DWORD buffsize = GetLongPathNameW(wshortpath.c_str(), nullptr, 0);
	if (buffsize == 0)
	{ // nothing to change (it doesn't exist, maybe?)
		return shortpath;
	}
	TArray<WCHAR> buff(buffsize, true);
	DWORD buffsize2 = GetLongPathNameW(wshortpath.c_str(), buff.Data(), buffsize);
	if (buffsize2 >= buffsize)
	{ // Failure! Just return the short path
		return shortpath;
	}
	FString longpath(buff.Data());
	return longpath;
}

#ifdef _USING_V110_SDK71_
//==========================================================================
//
// _stat64i32
//
// Work around an issue where stat() function doesn't work 
// with Windows XP compatible toolset.
// It uses GetFileInformationByHandleEx() which requires Windows Vista.
//
//==========================================================================

int _wstat64i32(const wchar_t *path, struct _stat64i32 *buffer)
{
	WIN32_FILE_ATTRIBUTE_DATA data;
	if(!GetFileAttributesExW(path, GetFileExInfoStandard, &data))
		return -1;

	buffer->st_ino = 0;
	buffer->st_mode = ((data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? S_IFDIR : S_IFREG)|
	                  ((data.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? S_IREAD : S_IREAD|S_IWRITE);
	buffer->st_dev = buffer->st_rdev = 0;
	buffer->st_nlink = 1;
	buffer->st_uid = 0;
	buffer->st_gid = 0;
	buffer->st_size = data.nFileSizeLow;
	buffer->st_atime = (*(uint64_t*)&data.ftLastAccessTime) / 10000000 - 11644473600LL;
	buffer->st_mtime = (*(uint64_t*)&data.ftLastWriteTime) / 10000000 - 11644473600LL;
	buffer->st_ctime = (*(uint64_t*)&data.ftCreationTime) / 10000000 - 11644473600LL;
	return 0;
}
#endif

int I_GetNumaNodeCount() { return 1; }
int I_GetNumaNodeThreadCount(int numaNode) { return std::max<int>(std::thread::hardware_concurrency(), 1); }
void I_SetThreadNumaNode(std::thread &thread, int numaNode) { }
void I_PrintStr(const char* str) { OutputDebugStringW(FString(str).WideString().c_str()); }

void ST_Endoom()
{
	throw CExitEvent(0);
}

void I_ShowFatalError(const char* message)
{
	FString zstr = message;
	OutputDebugStringW(FString(message).WideString().c_str());
	Windows::UI::Popups::MessageDialog msgdialog(ref new Platform::String(zstr.WideString().c_str()));
	std::atomic<bool> dlgfinished = false;
	Concurrency::create_task(msgdialog.ShowAsync()).then([&dlgfinished](Windows::UI::Popups::IUICommand^) { dlgfinished = true; });
	while (!dlgfinished) { Windows::UI::Core::CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(Windows::UI::Core::CoreProcessEventsOption::ProcessAllIfPresent); }
}

int I_PickIWad(WadStuff* wads, int numwads, bool showwin, int defaultiwad)
{
	return defaultiwad;
}

void PeekThreadedErrorPane() {}

bool I_WriteIniFailed()
{
	char* lpMsgBuf;
	FString errortext;

	FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
				   FORMAT_MESSAGE_FROM_SYSTEM |
				   FORMAT_MESSAGE_IGNORE_INSERTS,
				   NULL,
				   GetLastError(),
				   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				   (LPSTR)&lpMsgBuf,
				   0,
				   NULL
	);
	errortext.Format("The config file %s could not be written:\n%s", GameConfig->GetPathName(), lpMsgBuf);
	LocalFree(lpMsgBuf);
	//return MessageBoxA(Window, errortext.GetChars(), GAMENAME " configuration not saved", MB_ICONEXCLAMATION | MB_RETRYCANCEL) == IDRETRY;
	Platform::String^ string = ref new Platform::String(errortext.WideString().c_str());
	Windows::UI::Popups::MessageDialog msgdialog(string);
	std::atomic<bool> dlgfinished = false;
	Concurrency::create_task(msgdialog.ShowAsync()).then([&dlgfinished](Windows::UI::Popups::IUICommand^) { dlgfinished = true; });
	while (!dlgfinished) { Windows::UI::Core::CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(Windows::UI::Core::CoreProcessEventsOption::ProcessAllIfPresent); }
	return false;
}